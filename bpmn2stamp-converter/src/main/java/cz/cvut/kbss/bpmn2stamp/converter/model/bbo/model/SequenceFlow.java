
package cz.cvut.kbss.bpmn2stamp.converter.model.bbo.model;

import cz.cvut.kbss.bpmn2stamp.converter.model.bbo.Vocabulary;
import cz.cvut.kbss.jopa.model.annotations.*;

import java.io.Serializable;
import java.util.Set;


/**
 * A connecting object that shows the order in which activities are performed in a Process and is represented with a solid graphical line. Each Flow has only one source and only one target. A Sequence Flow can cross the boundaries between Lanes of a Pool but cannot cross the boundaries of a Pool.
 * 
 * This class was generated by OWL2Java 0.16.4
 * 
 */
@OWLClass(iri = Vocabulary.s_c_SequenceFlow)
public class SequenceFlow
    extends FlowElement
    implements Serializable
{

    /**
     * An optional boolean Expression that acts as a gating condition. A token will only
     * be placed on this Sequence Flow if this conditionExpression evaluates to
     * true.
     * 
     */
    @OWLObjectProperty(cascade = CascadeType.PERSIST, iri = Vocabulary.s_p_has_conditionExpression)
    @ParticipationConstraints({
//        @ParticipationConstraint(owlObjectIRI = Vocabulary.s_c_Expression, max = 1)
    })
    protected Expression has_conditionExpression;
    /**
     * The FlowNode that the Sequence Flow is connecting from.
     * For a Process: Of the types of FlowNode, only Activities, Gateways, and Events can be the source. However, Activities that are Event Sub-Processes are not allowed to be a source.
     * For a Choreography: Of the types of FlowNode, only Choreography Activities, Gateways, and Events can be the source.
     * 
     */
    @OWLObjectProperty(cascade = CascadeType.PERSIST, iri = Vocabulary.s_p_has_sourceRef)
    @ParticipationConstraints({
//        @ParticipationConstraint(owlObjectIRI = Vocabulary.s_c_FlowNode, min = 1, max = 1)
    })
    protected FlowNode has_sourceRef;
    /**
     * The FlowNode that the Sequence Flow is connecting to.
     * For a Process: Of the types of FlowNode, only Activities, Gateways, and Events can be the target. However, Activities that are Event Sub-Processes are not allowed to be a target.
     * For a Choreography: Of the types of FlowNode, only Choreography Activities, Gateways, and Events can be the target.
     * 
     */
    @OWLObjectProperty(cascade = CascadeType.PERSIST, iri = Vocabulary.s_p_has_targetRef)
    @ParticipationConstraints({
//        @ParticipationConstraint(owlObjectIRI = Vocabulary.s_c_FlowNode, min = 1, max = 1)
    })
    protected Set<Thing> has_targetRef;
    /**
     * An optional boolean value specifying whether Activities or Choreography Activities not in the model containing the Sequence Flow can occur between the elements connected by the Sequence Flow. If the value is true, they MAY NOT occur. If the value is false, they MAY occur. Also see the isClosed attribute on Process, Choreography, and Collaboration. When the attribute has no value, the
     * default semantics depends on the kind of model containing Sequence Flows:
     * • For non-executable Processes (public Processes and non-executable private Processes) and Choreographies no value has the same semantics as if the value were false.
     * • For an executable Processes no value has the same semantics as if the value were true.
     * • For executable Processes, the attribute MUST NOT be false.
     * 
     */
    @OWLDataProperty(iri = Vocabulary.s_p_isImmediate)
    @ParticipationConstraints({
//        @ParticipationConstraint(owlObjectIRI = "http://www.w3.org/2001/XMLSchema#boolean", max = 1)
    })
    protected Boolean isImmediate;

    public void setHas_conditionExpression(Expression has_conditionExpression) {
        this.has_conditionExpression = has_conditionExpression;
    }

    public Expression getHas_conditionExpression() {
        return has_conditionExpression;
    }

    public void setHas_sourceRef(FlowNode has_sourceRef) {
        this.has_sourceRef = has_sourceRef;
    }

    public FlowNode getHas_sourceRef() {
        return has_sourceRef;
    }

    public void setHas_targetRef(Set<Thing> has_targetRef) {
        this.has_targetRef = has_targetRef;
    }

    public Set<Thing> getHas_targetRef() {
        return has_targetRef;
    }

    public void setIsImmediate(Boolean isImmediate) {
        this.isImmediate = isImmediate;
    }

    public Boolean getIsImmediate() {
        return isImmediate;
    }

}
